# 第14章 轮廓

**说明**：  

1）图像通常包含各种物体，图像分析的目的之一就是**识别**和**提取**这些物体；

2）提取连续区域的工作是基于**二值图像**的。  

**Q**：**轮廓检测**和**边缘检测**的**区别**是什么？

**A**：虽然Canny之类的**边缘检测算法**可以根据像素间的差异**检测**出轮廓边界的像素，但是它并没有将轮廓作为一个**整体**进行处理,这真是**需要轮廓检测的原因**。

## 14.1 轮廓查找（Contour Finding）

**Q**：轮廓的**定义**是什么？

**A**：一个轮廓对应**一系列点**，这些点以某种方式表示图像中的**一条曲线**。

**Q**：OpenCV中是如何**表示**轮廓的？

**A**：轮廓几乎总是以标准模板库（STL）中的向量```vector<>```来表达，但并不一定局限于常见的```cv::Point```对象。

**Q**：函数```cv::findContours()```从**二值图像(binary image)**中计算轮廓的**基本原理**是什么？

**A**：该函数处理的图像可以是从```cv::Canny()```函数得到的有边缘像素的图像，或是从```cv::threshold()```或```cv::adaptiveThreshold()```函数得到边缘是正负区域之间的边界的图像。

### 14.1.1 轮廓层次(Contour Hierarchies)

**Q**：对轮廓进行层次划分的**目的**是什么？

**A**：对轮廓划分层次是为了对轮廓进行**筛选**做准备的。

**Q**：如何理解轮廓的层次结构？

**A**：参考资料[3]中“什么是层次结构hierarchy”部分的图非常直观，可以帮助理解。

Q：OpenCV中是如何表示层次结构的？

A：参考资料[3]讲的要比书上的好。在OpenCV中，每个轮廓都有自己的信息，关于它是什么层次结构，谁是它的子轮廓，谁是它的父轮廓等，这种数据结构与**树结构**很类似。OpenCV将它表示为四个int值的数组，Python接口中类型为1个1×4数组：[Next，Previous，First_Child，Parent]。关于这4个元素的具体函数，参考资料[3]讲的非常清晰。

**Q**：在OpenCV中，是如何表述轮廓的？

**A**：

1）在OpenCV中，是使用`cv::findContours()`函数来定位轮廓的，这些轮廓可以分为“轮廓”（contour）和“孔”（hole）；

2）OpenCV的`cv::findContours()`函数区分内部和外部边界。

**Q**：一幅图像可能存在多条轮廓，使用哪种数据结构来表示这种数据结构的关系呢？

**A**：由于轮廓存在父子关系和兄弟关系，使用使用**树**来描述这种数据结构的关系再合适不过了。OpenCV允许将找到的轮廓聚合成一棵**轮廓树**，在其结构中添加包含的关系。

Q：如何理解`cv::Vec4i`型数据结构？

#### 14.1.1.1 使用cv::findContours()查找轮廓

本小节较为详细的解释了该函数的各个参数，只有加强实践才能加深对这些参数的理解。

### 14.1.2 绘制轮廓

**Q**：在OpenCV中是如何绘制轮廓的？

**A**：获得一列轮廓后，一个最常用的功能是在屏幕上绘制检测到的轮廓。绘制轮廓可以用`cv::drawContours()`来完成。

**批注**：

1）本节的**相关知识**有`cv::Line()`、`cv::Scalar`等，在OpenCV+Python中的使用见官方教程中的“Drawing Line”；

2）本小节较为详细的解释了该函数的各个参数，只有加强实践才能加深对这些参数的理解。

### 14.1.3 轮廓实例（A Contour Example）

### 14.1.4 快速连通域分析（Fast Connected Component Analysis）

**Q**：连通域分析有什么用？

**A**：采用阈值化等方法分割一张图像后，我们可以采用连通区域分析来有效地对返回图像逐张**分离**和**处理**。

## 14.2 深入分析轮廓（More to Do with Contours）

Q：为什么要研究轮廓？

A：所有轮廓都是或即将是我们想要进行识别或操作的。

Q：深入分析轮廓包括哪些内容？

A：描述轮廓、简化或拟合轮廓、匹配轮廓到模板等等。

### 14.2.1 多边形逼近（Polygon Approximations）

**Q**：**为什么需要**多边形逼近？

**A**：当我们绘制一个多边形或进行形状分析时，通常需要使用多边形逼近一个轮廓，**使顶点数变少**。

#### 函数cv::approxPolyDP()进行多边形逼近

#### 理解Douglas-Peucker算法

**说明**：看书本我只理解了道格拉斯-普克算法的大体原理，深入理解该算法，我还是通过这里的链接[道格拉斯-普克算法（Douglas–Peucker algorithm）](https://blog.csdn.net/baimafujinji/article/details/6475432)理解的。

**Q**：如何理解**道格拉斯-普克算法**（**Douglas–Peucker algorithm**）？

**A**：在数学上，一条曲线包含了无数个点，但是计算机在存储曲线时只能存储有限个点，通常存储的点越多，那么对该曲线的描述也就越精确。但是，不是点数越多越好，点数较多会照成计算量的上升，我们进行目标定位，往往只需要该目标的大体轮廓就够了。为了实现这一想法，就产生了道格拉斯-普克算法。

**Q**：道格拉斯-普克算法的基本执行步骤有哪些？

**A**：博客中“图文结合”讲的很详细，浅显易懂。大体步骤总结如下，

1）确定首尾2点，将首尾2点连成直线；

2）设定一定距离阈值，判断离该直线最远的那个点（当然该点在这曲线点的集合内）是否小于该阈值，如果小于则舍弃该点，如果大于则保留；

3）如果最远点得到保留，将首点和该最远点连成直线段，该最远点和尾点连成直线段，对这2条直线段递归进行（2）、（3）步骤，直至处理完所有点。

**Q**：道格拉斯-普克算法的优点是什么？

**A**：道格拉斯-普克算法的优点是具有平移和旋转不变性，给定曲线与阈值后，抽样结果一定。

**Q**：如何使用C++实现道格拉斯-普克算法？

**A**：参考这里的链接[Ramer-Douglas-Peucker line simplification](https://rosettacode.org/wiki/Ramer-Douglas-Peucker_line_simplification)。

### 14.2.2 几何及特征概括（Geometry and Summary Characteristics）

**Q**：研究连通区域的目的是什么？

**A**：连通区域通常代表了场景中的某个物体。为了识别该物体或者将它与其他图像元素比较，需要对此区域进行测量，以提取部分特征。

**用cv::boundingRect()获得矩形包围框**

该算子源码根据图像深度是否为CV_8U有两种实现方式，目前我还没有理解这样做的原因。

**用cv::minAreaRect()获得最小矩形框**

**Q**：`cv::minAreaRect()`的输入和输出分别表示什么？

**A**：输入为任何标准形式的点集，且该函数无论对曲线还是普通点集，都是有用的。输出为表示外接矩形的数据类型`cv::RotatedRect`。

Q：如何理解`cv::RotatedRect`提供给我们的信息？

A：该矩形中心点的坐标、该矩形的宽高以及其倾斜角度。

Q：如果已知`cv::RotatedRect`信息，如何求该矩形的4个定点坐标？

A：想象该矩形是由其水平状态的矩阵旋转一定的角度而形成的，首先确定水平状态的矩阵中心点于该水平状态矩阵4个顶点形成的角度，然后再结合旋转角度，利用三角函数公式求旋转后矩阵的4个顶点的坐标。

**Q**：如何比较`cv::Rect`和`cv::RotatedRect`？

**A**：前者只能表现一个四边水平和垂直的矩形，后者可以表示倾斜的矩形。

**用cv::convexHull()获得轮廓的凸包**

Q：凸包（Convex Hull）的**概念**？

A：凸包是一个计算几何（图形学）中的概念，它的严格的数学定义为：在一个向量空间V中，对于给定集合X，所有包含X的凸集的交集S被称为X的凸包。直观上理解凸包，可以把它看作一条绕在区域周围的橡皮筋。在形状轮廓中凹进去的位置，凸包轮廓会与原始轮廓发生偏离。

Q：旋转卡壳的链接？

A：

[1] [【蒟蒻计算几何】旋转卡壳算法](https://jvruo.com/archives/79/)

[2] [OpenCV官方源码rotcalipers.cpp](https://github.com/opencv/opencv/blob/master/modules/imgproc/src/rotcalipers.cpp)

Q：旋转卡壳有什么用？

A：举个例子，如果在二维平面上给定n个点，求距离最远的2个点之间的距离？暴力求解的算法复杂度为O(n^2)，不可取。由于**最远点对**一定会出现在这些点集的**凸包**上，所以优秀的做法是，在凸包上使用复杂度低的O(n)的旋转卡壳算法进行求解。由下文可知，对踵点对距离中的最大值，就是在这个二维平面内2点距离的最大值，总的时间复杂度为O(n)。

Q：对踵点的定义？

A：在凸包上，被一对平行卡壳正好卡住的对应点称为对踵点。

Q：平行卡壳如何分类？

A：具体分类如下，直观上可以看连接中的图。

1）卡住两个点；

2）卡住一条边和一个点。

**结论**：一个对踵点到对应边之间的距离比其他点（这里的点指的是凸包上的点）要大。也就是说，一个对踵点和对应边所形成的三角形的面积是最大的。

Q：如何求解**对踵点**？

A：由于一个对踵点和对应边所形成的三角形的面积是最大的，所以我们可以使用叉积的第二种用法——求三角形面积来求解对踵点。

Q：如何通过C++实现旋转卡壳算法？

A：参考该链接吧。

Q：已知两个点，如何在图像上画直线？

A：这属于图形学的范畴，具体使用的算法是Bresenham直线算法与画圆算法，参考链接为[Bresenham直线算法与画圆算法](https://oldj.net/blog/2010/08/27/bresenham-algorithm)

### 14.2.3 几何学测试（Geometrical Tests）

**Q**：如何**计算任意多边形的面积**？

**A**：可以参考该链接[计算任意多边形的面积](https://www.cnblogs.com/TenosDoIt/p/4047211.html)。该博客有图有代码，代码简洁且健壮，有LeetCode风范。

## 14.3 匹配轮廓与图像（Matching Contours and Images）

### 14.3.1 矩

**Q**：轮廓的**矩**有什么用？

**A**：**比较两条轮廓**最简洁的方法之一是比较它们的轮廓矩。

**Q**：轮廓矩的物理意义是什么？

**A**：轮廓矩代表了一条轮廓、一幅图像、一组点集的某些高级特征。

Q：矩的数值定义是什么？

A：见书本。

**Q**：矩和几何中心（不严谨的称为重心）的关系是什么？

**A**：见书中“经过思考，你应该能理解对于同一张二值图，...，能得到整个对象的平均x值和y值。

## 参考资料

[1] 学习OpenCV 3 中文版 Learning OpenCV 3 英文版

[2] OpenCV计算机视觉编程攻略（第3版） [加] Robert Laganiere 著 相银初 译

[3] [OpenCV—轮廓操作一站式详解：查找/筛选/绘制/形状描述与重心标注(Python版)](https://blog.csdn.net/iracer/article/details/90695914)

[4] [OpenCV入门之寻找图像的凸包（convex hull）](https://www.cnblogs.com/jclian91/p/9728488.html)

